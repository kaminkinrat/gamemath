<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Math Multiverse: Neon Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Mitr:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --neon-blue: #00f2ff;
            --neon-pink: #ff00ea;
            --neon-purple: #bc13fe;
            --neon-gold: #ffcc00;
            --bg-dark: #02020a;
        }

        * {
            margin: 0; padding: 0; box-sizing: border-box;
            user-select: none; -webkit-touch-callout: none;
            font-family: 'Mitr', sans-serif;
        }

        body {
            background-color: var(--bg-dark);
            color: white;
            overflow: hidden;
            width: 100vw; height: 100dvh;
        }

        #game-container {
            position: relative;
            width: 100vw; height: 100dvh;
            background: #000;
            overflow: hidden;
        }

        canvas { width: 100%; height: 100%; display: block; position: absolute; inset: 0; }

        /* Combo Notification */
        #combo-notification {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 1800;
            opacity: 0;
            transition: opacity 0.2s ease-out;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #combo-notification.active {
            opacity: 1;
            animation: screen-shake 0.1s infinite;
        }

        @keyframes screen-shake {
            0% { transform: translate(2px, 2px); }
            50% { transform: translate(-2px, -2px); }
            100% { transform: translate(1px, -1px); }
        }

        .rainbow-rect {
            position: absolute;
            inset: 0px;
            border: 10px solid transparent;
            background: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #8b00ff) border-box;
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            animation: rainbow-rotate 1.5s linear infinite;
        }

        @keyframes rainbow-rotate {
            0% { filter: hue-rotate(0deg) brightness(1.1); }
            100% { filter: hue-rotate(360deg) brightness(1.3); }
        }

        /* UI Styling */
        .overlay {
            position: absolute; inset: 0;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.6); z-index: 2000; backdrop-filter: blur(8px);
            padding: 20px;
        }

        .hidden { display: none !important; }

        .panel {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(0, 242, 255, 0.4);
            border-radius: 30px;
            padding: 25px;
            text-align: center;
            width: 95%; max-width: 850px;
            box-shadow: 0 0 30px rgba(0, 242, 255, 0.15);
            max-height: 90dvh;
            overflow-y: auto;
            z-index: 2100;
        }

        .title { 
            font-size: 2.8rem; 
            background: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #00f2ff, #ff00ea);
            background-size: 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: text-rainbow 8s linear infinite;
            margin-bottom: 20px;
            font-weight: 700;
            text-shadow: 0 0 20px rgba(255,255,255,0.2);
        }

        @keyframes text-rainbow {
            0% { background-position: 0% 50%; }
            100% { background-position: 100% 50%; }
        }

        .mode-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }

        .mode-btn {
            background: rgba(255, 255, 255, 0.06);
            color: white;
            padding: 12px;
            border-radius: 15px;
            border: 1px solid rgba(0, 242, 255, 0.2);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .mode-btn:hover { background: rgba(0, 242, 255, 0.15); border-color: var(--neon-blue); transform: translateY(-3px); }

        #hud {
            position: absolute; top: 0; left: 0; width: 100%;
            padding: 15px 25px; display: flex; justify-content: space-between;
            align-items: center; pointer-events: none; z-index: 1000;
        }

        .hud-item { 
            background: rgba(0,0,0,0.7); 
            padding: 6px 15px; 
            border-radius: 20px; 
            border: 1.5px solid var(--neon-blue); 
            font-weight: 700; color: white;
            font-size: 0.85rem;
        }

        #choice-container {
            position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%);
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;
            width: 95%; max-width: 650px; z-index: 1500;
        }

        .choice-btn {
            background: rgba(0,0,0,0.5);
            border: 2px solid var(--neon-blue);
            color: white;
            padding: 12px 0;
            border-radius: 15px;
            font-size: 1.8rem;
            font-weight: 700;
            text-shadow: 0 0 8px var(--neon-blue);
            box-shadow: 0 4px 0 rgba(0, 242, 255, 0.4);
            transition: all 0.1s;
        }
        .choice-btn:active { transform: translateY(3px); box-shadow: 0 1px 0 var(--neon-blue); background: var(--neon-pink); }

        #orientation-overlay {
            position: fixed; inset: 0; background: #000; z-index: 10000;
            display: none; flex-direction: column; justify-content: center; align-items: center;
            text-align: center; padding: 20px;
        }
        @media screen and (orientation: portrait) { #orientation-overlay { display: flex; } }
    </style>
</head>
<body>

<div id="orientation-overlay">
    <div style="font-size: 4rem;">üì±üîÑ</div>
    <h2 style="margin-top: 20px;">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏´‡∏°‡∏∏‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô</h2>
</div>

<div id="game-container">
    <div id="combo-notification">
        <div class="rainbow-rect"></div>
        <div style="font-size: 4rem; font-weight: 900; color: white; text-shadow: 0 0 20px black;">COMBO!!</div>
    </div>

    <canvas id="mathBgCanvas"></canvas>
    <canvas id="mainCanvas"></canvas>

    <div id="hud" class="hidden">
        <div style="display: flex; gap: 8px;">
            <div class="hud-item">HP: <span id="hp-val">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span></div>
            <div class="hud-item">SCORE: <span id="score-val">0</span></div>
            <div class="hud-item" id="combo-hud" style="color: var(--neon-gold); display: none; border-color: var(--neon-gold);">COMBO: <span id="combo-val">0</span></div>
        </div>
        <button class="hud-item" style="background: var(--neon-pink); cursor:pointer; pointer-events: auto; border-color: white;" onclick="location.reload()">HOME</button>
    </div>

    <div id="choice-container" class="hidden">
        <button class="choice-btn" onpointerdown="app.submitChoice(0)">-</button>
        <button class="choice-btn" onpointerdown="app.submitChoice(1)">-</button>
        <button class="choice-btn" onpointerdown="app.submitChoice(2)">-</button>
        <button class="choice-btn" onpointerdown="app.submitChoice(3)">-</button>
    </div>

    <div id="menu-main" class="overlay">
        <div class="panel">
            <h1 class="title">MATH MULTIVERSE</h1>
            <div class="mode-grid" id="mode-grid-container"></div>
            <p style="color: var(--neon-blue); font-weight: 600; font-size: 0.9rem;">‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏ï‡πâ‡∏≠‡∏ô‡∏£‡∏±‡∏ö‡∏™‡∏π‡πà‡∏à‡∏±‡∏Å‡∏£‡∏ß‡∏≤‡∏•‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç</p>
        </div>
    </div>

    <div id="menu-result" class="overlay hidden">
        <div class="panel">
            <h1 class="title">GAME OVER</h1>
            <div id="result-stats" style="margin: 20px 0; font-size: 1.6rem; font-weight: 700; color: white;"></div>
            <button class="choice-btn" style="width: 100%;" onclick="location.reload()">‡πÄ‡∏•‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà</button>
        </div>
    </div>
</div>

<script>
const MODES = [
    { id: 'baby', name: '‡πÄ‡∏ö‡∏ö‡∏µ‡πã', emoji: 'üçº', range: 5, ops: ['+'], speedMul: 0.7 },
    { id: 'v_easy', name: '‡∏á‡πà‡∏≤‡∏¢‡∏°‡∏≤‡∏Å', emoji: 'üå∏', range: 10, ops: ['+', '-'], speedMul: 0.8 },
    { id: 'kid', name: '‡πÄ‡∏î‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢', emoji: 'üê∞', range: 15, ops: ['+', '-'], speedMul: 1.0 },
    { id: 'hyper', name: '‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÅ‡∏™‡∏á', emoji: '‚ö°', range: 20, ops: ['+', '-'], speedMul: 1.25, ramp: true },
    { id: 'multi', name: '‡πÄ‡∏ã‡∏µ‡∏¢‡∏ô‡∏Ñ‡∏π‡∏ì', emoji: '‚öîÔ∏è', range: 12, ops: ['*'], speedMul: 0.9 },
    { id: 'div', name: '‡∏´‡∏≤‡∏£‡∏™‡∏≤‡∏¢‡∏ü‡πâ‡∏≤', emoji: '‚ö°', range: 10, ops: ['/'], speedMul: 1.1 },
    { id: 'sonic', name: '‡πÇ‡∏ã‡∏ô‡∏¥‡∏Ñ', emoji: 'üöÄ', range: 25, ops: ['+', '-'], speedMul: 2.1 },
    { id: 'memory', name: '‡∏à‡∏≥‡πÇ‡∏à‡∏ó‡∏¢‡πå', emoji: 'üß†', range: 15, ops: ['+', '-'], hideProb: true, speedMul: 0.95, hideDelay: 120 },
    { id: 'titan', name: '‡∏ö‡∏≠‡∏™‡πÉ‡∏´‡∏ç‡πà', emoji: 'üë∫', range: 60, ops: ['+', '-', '*', '/'], speedMul: 1.6 },
    { id: 'chill', name: '‡∏ä‡∏¥‡∏•‡πÜ', emoji: 'üéã', range: 30, ops: ['+'], speedMul: 0.5, invul: true }
];

class SoundManager {
    constructor() { this.ctx = null; }
    init() { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); }
    playSuccess() { this.beep(880, 'sine', 0.2, 0.08); }
    playFail() { this.beep(110, 'sawtooth', 0.4, 0.12); }
    playCombo() { this.beep(1320, 'sine', 0.6, 0.15); }
    beep(freq, type, duration, vol) {
        if (!this.ctx) return;
        try {
            const osc = this.ctx.createOscillator();
            const g = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            g.gain.setValueAtTime(vol, this.ctx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
            osc.connect(g); g.connect(this.ctx.destination);
            osc.start(); osc.stop(this.ctx.currentTime + duration);
        } catch(e){}
    }
}
const sfx = new SoundManager();

const app = {
    canvas: null, ctx: null, 
    bgCanvas: null, bgCtx: null,
    state: 'menu',
    score: 0, hp: 4, combo: 0,
    activeMode: null,
    problems: [], particles: [], stars: [],
    choices: [], currentTarget: null,
    lastSpawn: 0,
    spawnDelay: 2000, 
    speedFactor: 1.0,
    hueOffset: 0,

    init() {
        this.canvas = document.getElementById('mainCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.bgCanvas = document.getElementById('mathBgCanvas');
        this.bgCtx = this.bgCanvas.getContext('2d');
        this.renderMenu();
        this.resize();
        this.initSpaceBg();
        window.addEventListener('resize', () => this.resize());
        this.loop();
    },

    resize() {
        this.canvas.width = this.bgCanvas.width = window.innerWidth;
        this.canvas.height = this.bgCanvas.height = window.innerHeight;
        this.initSpaceBg();
    },

    initSpaceBg() {
        const chars = ['œÄ', 'Œ£', '‚àû', '‚àö', '‚à´', 'x', 'y', 'z', 'f', 'Œª', 'Œ∏', 'Œî', '1', '0', '+', '-', '='];
        this.stars = [];
        // ‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏°‡∏ô‡∏π‡∏à‡∏∞‡∏°‡∏µ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ß‡πâ‡∏≤‡∏ß
        const count = this.state === 'menu' ? 60 : 25; 
        for(let i=0; i<count; i++) {
            this.stars.push({
                x: Math.random() * this.canvas.width - this.canvas.width/2,
                y: Math.random() * this.canvas.height - this.canvas.height/2,
                z: Math.random() * this.canvas.width,
                char: chars[Math.floor(Math.random() * chars.length)],
                vx: (Math.random() - 0.5) * 0.5, // ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÅ‡∏ô‡∏ß‡∏£‡∏≤‡∏ö‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏°‡∏ô‡∏π
                vy: (Math.random() - 0.5) * 0.5
            });
        }
    },

    renderMenu() {
        const container = document.getElementById('mode-grid-container');
        MODES.forEach(m => {
            const btn = document.createElement('button');
            btn.className = 'mode-btn';
            btn.innerHTML = `<div style="font-size:1.6rem; margin-bottom:5px;">${m.emoji}</div><div style="font-weight:700; font-size:0.85rem;">${m.name}</div>`;
            btn.onclick = () => { sfx.init(); this.start(m); };
            container.appendChild(btn);
        });
    },

    start(mode) {
        this.activeMode = mode;
        this.state = 'play';
        this.score = 0; this.hp = 4; this.combo = 0; this.speedFactor = 1.0;
        this.problems = []; this.particles = [];
        this.lastSpawn = Date.now();
        this.initSpaceBg(); // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á‡πÉ‡∏´‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏•‡πà‡∏ô (‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ô‡πâ‡∏≠‡∏¢‡∏•‡∏á)
        document.getElementById('menu-main').classList.add('hidden');
        document.getElementById('hud').classList.remove('hidden');
        document.getElementById('choice-container').classList.remove('hidden');
        this.spawnProblem();
        this.updateHUD();
    },

    spawnProblem() {
        const m = this.activeMode;
        let a, b, op, ans;
        op = m.ops[Math.floor(Math.random() * m.ops.length)];
        const range = m.range + Math.floor(this.score / 100);

        if (op === '+') { a = rand(1, range); b = rand(1, range); ans = a + b; }
        else if (op === '-') { a = rand(5, range + 5); b = rand(1, a); ans = a - b; }
        else if (op === '*') { a = rand(2, 12); b = rand(2, 10); ans = a * b; }
        else if (op === '/') { b = rand(2, 10); ans = rand(1, 10); a = ans * b; op = '√∑'; }

        const prob = {
            id: Date.now() + Math.random(),
            text: `${a} ${op === '*' ? '√ó' : op} ${b}`,
            ans: ans,
            x: 150 + Math.random() * (this.canvas.width - 300),
            y: -50,
            speed: (0.7 + (this.score / 900)) * m.speedMul * this.speedFactor,
            hide: m.hideProb,
            hideTimer: m.hideDelay || 0,
            seed: Math.random() * 360 
        };

        this.problems.push(prob);
        if (this.problems.length === 1) this.updateChoices();
        this.spawnDelay = Math.max(900, 2400 / this.speedFactor);
    },

    updateChoices() {
        if (this.problems.length === 0) return;
        this.currentTarget = this.problems[0];
        const correct = this.currentTarget.ans;
        let c = [correct];
        while (c.length < 4) {
            let fake = correct + rand(-12, 12);
            if (fake >= 0 && !c.includes(fake)) c.push(fake);
        }
        this.choices = c.sort(() => Math.random() - 0.5);
        const btns = document.querySelectorAll('.choice-btn');
        btns.forEach((btn, i) => btn.innerText = this.choices[i]);
    },

    submitChoice(idx) {
        if (this.state !== 'play' || !this.currentTarget) return;
        if (this.choices[idx] === this.currentTarget.ans) {
            this.score += 10 + (this.combo * 5);
            this.combo++;
            if (this.activeMode.ramp) this.speedFactor += 0.025;
            
            if (this.combo > 0 && this.combo % 5 === 0) this.triggerComboAlert();

            this.explode(this.currentTarget.x, this.currentTarget.y, `hsl(${this.hueOffset}, 100%, 70%)`);
            this.problems.shift();
            this.updateChoices();
            sfx.playSuccess();
            this.lastSpawn = Date.now() - 600;
        } else {
            this.combo = 0;
            this.triggerPenalty();
            sfx.playFail();
        }
        this.updateHUD();
    },

    triggerComboAlert() {
        sfx.playCombo();
        if (navigator.vibrate) navigator.vibrate([80, 40, 80]);
        const notification = document.getElementById('combo-notification');
        notification.classList.add('active');
        setTimeout(() => notification.classList.remove('active'), 1200);
    },

    triggerPenalty() {
        if (!this.activeMode.invul) this.hp--;
        if (navigator.vibrate) navigator.vibrate([200]);
        if (this.hp <= 0) this.gameOver();
    },

    updateHUD() {
        document.getElementById('score-val').innerText = this.score;
        document.getElementById('hp-val').innerText = this.activeMode.invul ? '‚àû' : '‚ù§Ô∏è'.repeat(this.hp);
        const comboHud = document.getElementById('combo-hud');
        if (this.combo >= 2) {
            comboHud.style.display = 'block';
            document.getElementById('combo-val').innerText = this.combo;
        } else {
            comboHud.style.display = 'none';
        }
    },

    gameOver() {
        this.state = 'over';
        if (navigator.vibrate) navigator.vibrate([500]);
        document.getElementById('menu-result').classList.remove('hidden');
        document.getElementById('result-stats').innerText = `üèÜ ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: ${this.score} | üî• ‡∏Ñ‡∏≠‡∏°‡πÇ‡∏ö: ${this.combo}`;
    },

    explode(x, y, color) {
        for(let i=0; i<12; i++) {
            this.particles.push({
                x, y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10,
                life: 1, size: Math.random()*3+1.5, color: color
            });
        }
    },

    update() {
        this.hueOffset = (this.hueOffset + 1) % 360;

        // ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á: ‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏°‡∏ô‡∏π‡∏à‡∏∞‡∏•‡∏≠‡∏¢‡πÄ‡∏≠‡∏∑‡πà‡∏≠‡∏¢‡πÜ ‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏•‡πà‡∏ô‡∏à‡∏∞‡∏û‡∏∏‡πà‡∏á
        if (this.state === 'menu') {
            this.stars.forEach(s => {
                s.x += s.vx; s.y += s.vy;
                if (s.x > this.canvas.width/2) s.x = -this.canvas.width/2;
                if (s.x < -this.canvas.width/2) s.x = this.canvas.width/2;
                if (s.y > this.canvas.height/2) s.y = -this.canvas.height/2;
                if (s.y < -this.canvas.height/2) s.y = this.canvas.height/2;
            });
        } else {
            const warpSpeed = 2 + (this.score/500);
            this.stars.forEach(s => {
                s.z -= warpSpeed;
                if (s.z <= 0) {
                    s.z = this.canvas.width;
                    s.x = Math.random() * this.canvas.width - this.canvas.width/2;
                    s.y = Math.random() * this.canvas.height - this.canvas.height/2;
                }
            });
        }

        if (this.state !== 'play') return;
        
        let now = Date.now();
        // ‡πÄ‡∏≠‡∏≤‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç problems.length < 3 ‡∏≠‡∏≠‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÑ‡∏´‡∏•‡∏•‡∏á‡∏°‡∏≤‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏¢‡πÜ ‡πÑ‡∏î‡πâ‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß
        const maxActive = this.speedFactor > 1.5 ? 5 : 3;
        if (now - this.lastSpawn > this.spawnDelay && this.problems.length < maxActive) {
            this.spawnProblem();
            this.lastSpawn = now;
        }

        this.problems.forEach((p, i) => {
            p.y += p.speed;
            if (p.hideTimer > 0) p.hideTimer--;
            if (p.y > this.canvas.height - 90) {
                this.problems.splice(i, 1);
                this.combo = 0;
                this.triggerPenalty();
                this.updateChoices();
                this.updateHUD();
                this.lastSpawn = Date.now();
            }
        });

        this.particles.forEach((p, i) => {
            p.x += p.vx; p.y += p.vy; p.life -= 0.04;
            if(p.life <= 0) this.particles.splice(i, 1);
        });
    },

    draw() {
        this.bgCtx.fillStyle = '#010106';
        this.bgCtx.fillRect(0, 0, this.bgCanvas.width, this.bgCanvas.height);
        
        const cx = this.bgCanvas.width / 2;
        const cy = this.bgCanvas.height / 2;
        
        if (this.state === 'menu') {
            // ‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏°‡∏ô‡∏π: ‡∏•‡∏≠‡∏¢‡πÅ‡∏ö‡∏ö‡∏ä‡∏¥‡∏•‡∏•‡πå‡πÜ
            this.stars.forEach(s => {
                const sx = s.x + cx;
                const sy = s.y + cy;
                this.bgCtx.globalAlpha = 0.4;
                this.bgCtx.fillStyle = `hsl(${(this.hueOffset + s.z/2)%360}, 60%, 70%)`;
                this.bgCtx.font = `20px Mitr`;
                this.bgCtx.fillText(s.char, sx, sy);
            });
        } else {
            // ‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏•‡πà‡∏ô: ‡∏û‡∏∏‡πà‡∏á‡πÅ‡∏ö‡∏ö‡∏õ‡∏£‡∏∞‡∏´‡∏¢‡∏±‡∏î‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Å‡∏ï‡πå
            this.stars.forEach(s => {
                const sx = (s.x / s.z) * cx + cx;
                const sy = (s.y / s.z) * cy + cy;
                const size = (1 - s.z / this.bgCanvas.width) * 10;
                const alpha = (1 - s.z / this.bgCanvas.width) * 0.4;

                this.bgCtx.globalAlpha = alpha;
                this.bgCtx.fillStyle = `hsl(${(this.hueOffset + s.z)%360}, 40%, 60%)`;
                this.bgCtx.font = `bold ${size + 6}px Mitr`;
                this.bgCtx.fillText(s.char, sx, sy);
            });
        }

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.problems.forEach(p => {
            const isTarget = this.currentTarget && p.id === this.currentTarget.id;
            
            this.ctx.font = `bold ${isTarget ? '38' : '28'}px 'Mitr'`;
            this.ctx.textAlign = 'center';
            let txt = (p.hide && p.hideTimer <= 0) ? '???' : p.text;
            
            const gradient = this.ctx.createLinearGradient(p.x - 35, p.y, p.x + 35, p.y);
            gradient.addColorStop(0, `hsl(${this.hueOffset + p.seed}, 100%, 70%)`);
            gradient.addColorStop(1, `hsl(${this.hueOffset + p.seed + 60}, 100%, 70%)`);
            
            this.ctx.fillStyle = gradient;
            this.ctx.shadowBlur = isTarget ? 12 : 0;
            this.ctx.shadowColor = `hsl(${this.hueOffset + p.seed}, 100%, 50%)`;
            this.ctx.fillText(txt, p.x, p.y);
            this.ctx.shadowBlur = 0;
            
            if (isTarget) {
                const time = Date.now() * 0.003;
                this.ctx.save();
                this.ctx.translate(p.x, p.y - 10);
                this.ctx.rotate(time);
                
                // ‡∏ß‡∏á‡∏Å‡∏•‡∏°‡∏ô‡∏µ‡∏≠‡∏≠‡∏ô‡∏Ç‡∏ô‡∏≤‡∏î‡∏û‡∏≠‡∏î‡∏µ‡πÇ‡∏à‡∏ó‡∏¢‡πå
                this.ctx.shadowBlur = 12;
                this.ctx.shadowColor = varColor('--neon-pink');
                this.ctx.strokeStyle = varColor('--neon-pink');
                this.ctx.lineWidth = 3;
                this.ctx.setLineDash([10, 6]);
                
                this.ctx.beginPath();
                this.ctx.arc(0, 0, 52, 0, Math.PI * 2);
                this.ctx.stroke();
                
                this.ctx.rotate(-time * 1.5);
                this.ctx.strokeStyle = varColor('--neon-blue');
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([3, 3]);
                this.ctx.beginPath();
                this.ctx.arc(0, 0, 45, 0, Math.PI * 2);
                this.ctx.stroke();
                
                this.ctx.restore();
            }
        });

        this.particles.forEach(p => {
            this.ctx.globalAlpha = p.life;
            this.ctx.fillStyle = p.color;
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
            this.ctx.fill();
        });
        this.ctx.globalAlpha = 1;
    },

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
};

function rand(min, max) { return Math.floor(Math.random() * (max - min + 1) + min); }
function varColor(name) { return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
window.onload = () => app.init();
</script>
</body>
</html>
